//! Implementation for `za gen`.

use anyhow::{anyhow, Context, Result};
use std::{
    fs::{self, File},
    io::{self, Write},
    path::{Path, PathBuf},
    sync::atomic::AtomicBool,
    time::{SystemTime, UNIX_EPOCH},
};

use crate::command::{lang_of, md_header, walk_workspace, BinaryFile, TextFile};

/// Entry for `za gen`
/// If `repo` is provided, clone into a temp dir with gix (rustls), optionally checkout `rev`,
/// and (optionally) descend into `repo_subdir` to scan. The output path is resolved *before* changing
/// directories so it's written to the original CWD.
pub fn run(
    max_lines: usize,
    output: PathBuf,
    include_binary: bool,
    repo: Option<String>,
    rev: Option<String>,
    repo_subdir: Option<PathBuf>,
    keep_clone: bool,
) -> Result<()> {
    // Resolve output to absolute path to avoid being affected by cwd changes.
    let output_abs = if output.is_absolute() {
        output
    } else {
        std::env::current_dir()?.join(output)
    };

    match repo {
        None => {
            // Local mode (existing behavior)
            let (texts, bins) = walk_workspace(include_binary)?;
            write_context_md(&texts, &bins, max_lines, &output_abs)?;
            println!("âœ… Generated {}", output_abs.display());
        }
        Some(url) => {
            // Remote mode via gix (pure Rust, rustls)
            let clone_dir = clone_and_prepare_gix(&url, rev.as_deref())?;
            let scan_root = if let Some(sub) = repo_subdir {
                let p = clone_dir.join(sub);
                if !p.exists() {
                    return Err(anyhow!("repo-subdir not found in clone: {}", p.display()));
                }
                p
            } else {
                clone_dir.clone()
            };

            // Switch cwd to scan root for walking
            {
                let _cwd = CwdGuard::push(&scan_root)?;
                let (texts, bins) = walk_workspace(include_binary)?;
                write_context_md(&texts, &bins, max_lines, &output_abs)?;
            } // restore cwd here

            println!("âœ… Generated {} (from repo {})", output_abs.display(), url);

            if !keep_clone {
                // Best-effort cleanup; ignore errors to avoid masking success.
                if let Err(e) = fs::remove_dir_all(&clone_dir) {
                    eprintln!("âš ï¸  Failed to remove temp clone {}: {e}", clone_dir.display());
                }
            } else {
                println!("â„¹ï¸  Clone kept at: {}", clone_dir.display());
            }
        }
    }

    Ok(())
}

/// Render `CONTEXT.md`
fn write_context_md(
    texts: &[TextFile],
    bins: &[BinaryFile],
    max: usize,
    out: &Path,
) -> io::Result<()> {
    let mut f = File::create(out)?;
    md_header(&mut f, "# ğŸ“š Project Context â€” generated by za")?;

    // --- deterministic, sorted directory listing ---
    let mut texts_sorted = texts.to_vec();
    texts_sorted.sort_by(|a, b| a.rel.cmp(&b.rel));
    let mut bins_sorted = bins.to_vec();
    bins_sorted.sort_by(|a, b| a.rel.cmp(&b.rel));

    writeln!(f, "## 1. Directory Overview\n```text")?;
    for t in &texts_sorted {
        writeln!(f, "({:<4}) {}", t.lines.len(), t.rel.display())?;
    }
    for b in &bins_sorted {
        let mib = b.bytes as f64 / 1_048_576.0;
        writeln!(f, "(bin {:>5.2} MiB) {}", mib, b.rel.display())?;
    }
    writeln!(f, "```\n")?;

    // --- code snippets with dynamic fence length ---
    writeln!(f, "## 2. File Snippets\n")?;
    for t in &texts_sorted {
        let content = snippet(&t.lines, max);
        let fence = pick_fence(&content);
        let lang = lang_of(&t.rel);
        writeln!(
            f,
            "<details><summary>{}</summary>\n\n{fence}{lang}\n{}\n{fence}\n</details>\n",
            t.rel.display(),
            content
        )?;
    }
    Ok(())
}

/// Truncate long files for preview
fn snippet(lines: &[String], max: usize) -> String {
    if lines.len() <= max {
        return lines.join("\n");
    }
    // Split budget roughly half-half for head and tail.
    let front = (max + 1) / 2;
    let back = max - front;

    format!(
        "{}\nâ‹¯(truncated)\n{}",
        lines[..front].join("\n"),
        lines[lines.len().saturating_sub(back)..].join("\n")
    )
}

/// Pick a code fence that won't collide with the content.
/// Starts with ``` and grows until it's unique.
fn pick_fence(content: &str) -> String {
    let mut fence = "```".to_string();
    while content.contains(&fence) {
        fence.push('`');
    }
    fence
}

/// RAII guard for temporarily changing current working directory.
struct CwdGuard {
    prev: PathBuf,
}
impl CwdGuard {
    fn push(dir: &Path) -> io::Result<Self> {
        let prev = std::env::current_dir()?;
        std::env::set_current_dir(dir)?;
        Ok(Self { prev })
    }
}
impl Drop for CwdGuard {
    fn drop(&mut self) {
        let _ = std::env::set_current_dir(&self.prev);
    }
}

/// Create a unique temp directory under the system temp path.
fn unique_temp_dir(prefix: &str) -> Result<PathBuf> {
    let base = std::env::temp_dir();
    let ts = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis();
    let pid = std::process::id();
    let dir = base.join(format!("{prefix}-{ts}-{pid}"));
    fs::create_dir(&dir).with_context(|| format!("create temp dir {}", dir.display()))?;
    Ok(dir)
}

/// Heuristic: looks like a commit SHA (7~40 hex)
fn is_likely_commit_sha(s: &str) -> bool {
    let len = s.len();
    (7..=40).contains(&len) && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Clone via gix (pure Rust, rustls HTTP/S), optionally check out `rev`.
/// - If `rev` looks like branch/tag/ref name, use `with_ref_name()` then fetch+checkout;
/// - If `rev` looks like a commit SHAï¼Œå½“å‰ç‰ˆæœ¬ä¼˜é›…é™çº§ä¸ºæ£€å‡ºé»˜è®¤åˆ†æ”¯ HEADï¼ˆæ‰“å°æç¤ºï¼Œä¸æŠ¥é”™ï¼‰ã€‚
fn clone_and_prepare_gix(url: &str, rev: Option<&str>) -> Result<PathBuf> {
    let clone_dir = unique_temp_dir("za-clone")?;

    // Prepare clone
    let mut prep = gix::prepare_clone(url, &clone_dir)
        .with_context(|| format!("prepare clone for {url} -> {}", clone_dir.display()))?;

    if let Some(name) = rev {
        if is_likely_commit_sha(name) {
            eprintln!("âš ï¸  `--rev` looks like a commit SHA. Falling back to default HEAD checkout (pure gix path).");
        } else {
            // Treat as branch/tag/ref name
            prep = prep
                .with_ref_name(Some(name))
                .with_context(|| format!("set ref name '{name}'"))?;
        }
    }

    // Fetch + checkout with blocking client
    let cancel = AtomicBool::new(false);
    let (mut checkout, _outcome) = prep
        .fetch_then_checkout(gix::progress::Discard, &cancel)
        .context("fetch_then_checkout")?;

    // Materialize main worktree
    let (_repo, _worktree) = checkout
        .main_worktree(gix::progress::Discard, &cancel)
        .context("checkout main worktree")?;

    Ok(clone_dir)
}

#[cfg(test)]
mod tests {
    use super::snippet;

    #[test]
    fn snippet_preserves_odd_max_lines() {
        let lines: Vec<String> = (1..=10).map(|i| format!("line{}", i)).collect();
        let out = snippet(&lines, 5);
        assert_eq!(out, "line1\nline2\nline3\nâ‹¯(truncated)\nline9\nline10");
    }

    #[test]
    fn snippet_preserves_even_max_lines() {
        let lines: Vec<String> = (1..=10).map(|i| format!("line{}", i)).collect();
        let out = snippet(&lines, 4);
        assert_eq!(out, "line1\nline2\nâ‹¯(truncated)\nline9\nline10");
    }
}
